module au_top (
    input clk,              // 100MHz clock
    input rst_n,            // reset button (active low)
    output led [8],         // 8 user controllable LEDs
    input usb_rx,           // USB->Serial input
    output outled,           // to LED strip, Br pin C49, connect LED Strip to 5V for power
    output usb_tx,          // USB->Serial output
    output io_led [3][8],   // LEDs on IO Shield
    output io_seg [8],      // 7-segment LEDs on IO Shield
    output io_sel [4],      // Digit select on IO Shield
    input io_button [5],    // 5 buttons on IO Shield
    input io_dip [3][8]     // DIP switches on IO Shield
  ) {
  
  // We shall always assume that COLUMN_DIMENSION and ROW_DIMENSION is a 2^x
  const COLUMN_DIMENSION = 24; // how many "columns"? 
  const ROW_DIMENSION = 1; // how many "rows"?

  const PIXEL_COUNT = COLUMN_DIMENSION *  ROW_DIMENSION;   
  const ENCODING_AMOUNT = 4; // how many different encodings are used? As example, we use 4
  
  // WHITE (11), BLUE (10), RED (01), OFF (00)
  const LEDCOLOR = {24hFFFFFF, 24hFF0000, 24h00FF00, 24h000000}; 
  
  sig rst; // reset signal
  sig encoded_pixel_address[$clog2(PIXEL_COUNT)*$clog2(ENCODING_AMOUNT)];
  sig current_color_encoding[$clog2(ENCODING_AMOUNT)];

  var index;

  // dff initialisation done in FSM for more reliability 
  // sometimes #INIT in here is not registered, especially for large dffs
  // tried: #INIT of player_position works, but not consumable_position
  dff led_encoding[PIXEL_COUNT*$clog2(ENCODING_AMOUNT)](.clk(clk), .rst(rst), #INIT(0)); // 2 bit to encode a color per pixel
  dff consumable_position[PIXEL_COUNT*$clog2(ENCODING_AMOUNT)](.clk(clk), .rst(rst), #INIT(0)); // place blue at pixel position 0, remember that each pixel takes 2 bits 
  dff player_position[PIXEL_COUNT*$clog2(ENCODING_AMOUNT)](.clk(clk), .rst(rst), #INIT(0)); 
  dff direction(.clk(clk), .rst(rst), #INIT(1)); // 1 direction means to increase pixel index, 0 means to decrease pixel index
  
  ws2812b_writer led_strip(#PIXEL_COUNT(PIXEL_COUNT), .clk(clk), .rst(rst)); 
  fsm state(.clk(clk), .rst(rst)) = {INIT, LOAD, IDLE};
  
  // user inputs 
  button_conditioner reverse_button(.clk(clk));
  edge_detector reverse_button_edge(.clk(clk), #RISE(1), #FALL(0));
  edge_detector delay_edge(.clk(clk), #RISE(1), #FALL(0));
  
  reverser index_reverser(#COLUMN_DIMENSION(COLUMN_DIMENSION), #ROW_DIMENSION(ROW_DIMENSION), #ENCODING_AMOUNT(ENCODING_AMOUNT));
  
  .clk(clk) {
    // The reset conditioner is used to synchronize the reset signal to the FPGA
    // clock. This ensures the entire FPGA comes out of reset at the same time.
    reset_conditioner reset_cond;
    counter delay(.rst(rst), #DIV(26), #SIZE(1));
  }
  
  always {
    reset_cond.in = ~rst_n; // input raw inverted reset signal
    rst = reset_cond.out;   // conditioned reset
    
    usb_tx = usb_rx;        // loop serial port
    
    led = 8h00;             // turn LEDs off
    
    io_led = 3x{{8h00}};    // turn LEDs off
    io_seg = 8hff;          // turn segments off
    io_sel = 4hf;           // select no digits
    
    
    reverse_button.in = io_button[1]; // use this button to enable reverse direction of player position
    reverse_button_edge.in = reverse_button.out;
    delay_edge.in = delay.value;
    
    led_strip.update = 0; // do not refresh by default
    led_strip.clear = 0; // do not clear by default
    
    if (reverse_button_edge.out){
      direction.d = ~direction.q; // reverse player when reverse button is pressed
    }
    

    // use io_dip[1:0]  to encode 8 unique pixel values
    case (state.q){
      state.IDLE:
            if (delay_edge.out){
            if (direction.q){
            // check if player is at the 24th position, if yes, reset to position 0
            if (player_position.q[46]){
              player_position.d = player_position.q >> (COLUMN_DIMENSION-1)*2;
            }
            else{
                      // increase player position regularly
                     player_position.d = player_position.q << 2;           
            }
            }
          else{
            // check if player is at the 0th position 
            if (player_position.q[0]){
              player_position.d = player_position.q << (COLUMN_DIMENSION-1)*2;
            }
            else{
               // decrease player position 
               player_position.d = player_position.q >> 2; 
            }
          }
          state.d = state.LOAD;
             }
             
      
      state.INIT: 
           if (led_strip.reset & delay.value){ //  you need to artificially introduce some delay before sending data to the LED strip
               state.d = state.LOAD;
               consumable_position.d = 48b10;
               player_position.d = 48h400000000000;
           }
        
      state.LOAD:
            // wait until we are at RESET state before we decide to refresh the screen
            if (led_strip.reset){
                // tell the LED to update the pixels
                led_strip.update = 1;
                led_encoding.d = player_position.q | consumable_position.q; 
                state.d = state.IDLE;
            }
    }
    
    // connect reverser to led_strip 
    index_reverser.original_pixel_address = led_strip.pixel_address;
    index_reverser.activate = 0; 
    encoded_pixel_address = index_reverser.effective_pixel_address * $clog2(ENCODING_AMOUNT);
 
   // get current color encoding for this pixel
    for (index=0; index<$clog2(ENCODING_AMOUNT); index++){
       current_color_encoding[index] = led_encoding.q[encoded_pixel_address+index];
    }
    
    // based on the encoding extracted from dff led_encoding, we get the 24bit color value
    led_strip.color = LEDCOLOR[current_color_encoding]; 
    outled=led_strip.led;
    
    // debug 
    // show the current LED color
    if (io_dip[0][0]){
    io_led[0] = led_encoding.q[7:0];
    io_led[1] = led_encoding.q[15:8];
    io_led[2] = led_encoding.q[23:16];
    }
    if (io_dip[0][1]){
    io_led[0] = led_encoding.q[31:24];
    io_led[1] = led_encoding.q[39:32];
    io_led[2] = led_encoding.q[47:40];    
    }
    if (io_dip[0][2]){
    io_led[0] = player_position.q[7:0];
    io_led[1] = player_position.q[15:8];
    io_led[2] = player_position.q[23:16];
    }
    if(io_dip[0][3]){
    io_led[0] = player_position.q[31:24];
    io_led[1] = player_position.q[39:32];
    io_led[2] = player_position.q[47:40];    
    }
    if (io_dip[0][4]){
    io_led[0] = consumable_position.q[7:0];
    io_led[1] = consumable_position.q[15:8];
    io_led[2] = consumable_position.q[23:16];    
      
    }
    if(io_dip[0][5]){
    io_led[0] = consumable_position.q[31:24];
    io_led[1] = consumable_position.q[39:32];
    io_led[2] = consumable_position.q[47:40];   
    }
   
    led[0] = direction.q;
    led[7:1] = led_strip.pixel_address;
    

    
  }
}